---
id: doc-overview
title: Design Overview
---

## High Level Design

The high level design is split into three phases.

1. Convert LLVM IR to "RaceIR" (need a better name)
2. Convert "RaceIR" to a trace of events
3. Run analyses on the program trace

TODO: image here

### Phase I: Converting LLVM IR to RaceIR

The RaceIR acts as a high level interface tp wrap LLVM IR.

For example, there are lots of llvm instructions we would like to treat as logical reads.

```
    %a = load %val
    %b = call @memcopy(...)
    %c = call @vector_bracket_operator(...)
```

RaceIR defines an interface for the logical operations we care about (read/write/fork/join/etc.), without dealing with
the underlying llvm instructions directly.

The RaceIR interface for read might look something like:

```cpp
class Read {
public:
    virtual const llvm::Inst* getInst() const =  0;
    virtual const llvm::Value *getReadValue() const = 0;
};
```

Now to treat different types of llvm instructions as reads, we just need to define a derived class implementing the read
interface.

```cpp
class Load : public Read {
    const LoadInst *load;
public:
    const llvm::LoadInst* getInst() const override { return load; }
    const llvm::Value *getReadValue() const override { return load->getPointerOperand(); }
};

class MemCpyRead : public Read {
    const CallBase *inst;
public:
    const llvm::LoaCallBasedInst* getInst() const override { return inst; }

    // Assuming 3rd operand is the value being read. This is a fake example
    const llvm::Value *getReadValue() const override { return load->getOperand(3); }
};
```

The same interface defined for all the logical operations we care about. This way later phases can directly access the
info they care about (e.g. what memory is being read) without having to deal with udnerlying llvm instructions directly.

The actual work done in the first phase is converting LLVM IR to "RaceIR".

For this there is an InfoBuilder class that takes an LLVM IR Function and returns RaceIRFunction containing only the
relevant wrapped "RaceIR" instructions.

// TODO: Put image here from my presentation

### Phase II: Converting RaceIR to a Trace of Events

This phase simulates execution of the RaceIR (and by proxy llvm IR) across multiple threads and generates a static trace
of events.

Events in the trace represent actual events being executed in a program.

"RaceIR" classes answer questions in terms of llvm IR. TraceEvents answer questions in terms of (static) execution.

While the read interface in "RaceIR" has a function that tells us what llvm value is being accessed, a read event will
have a function telling us what logical memory is being accessed.

```cpp
class Read {
    const llvm::Value *getAccessedValue() const;
};

class ReadEvent {
    std::vector<AbstractObj> getAccessedMemory() const;
};
```

Internally, events are essentially bundling RaceIR and pointer analysis (PTA) info together, and traces are constructed
by traversing the callgraph generated by PTA.

The main purpose of a seperate "Trace" phase and class is to hide the details of PTA from later phases.

### Phase III: Analysis

Once a trace has been generated, analyses can be run on that trace by examining events and querying their APIs.

The three main analyses we care about for race detection are:

1. SharedMemory - find shared accesses across threads
2. HappensBefore - find events executed in parallel
3. Lockset - find out what locks an event holds

#### SharedMemory Analysis

TODO

#### HappensBefore Analysis

TODO

#### Lockset Analysis

TODO